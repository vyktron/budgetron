from pymongo import MongoClient
from model.db.data import Account, Transaction, User
from bson.objectid import ObjectId
import json

class DBClient:
    def __init__(self, host : str, port : int, username : str, password : str):
        """
        Constructor for the MongoDBClient class

        Parameters:
        ----------
        host: str
            The host of the database
        port: int
            The port of the database
        username: str
            The username of the database
        password: str
            The password of the database
        """

        self.client = MongoClient(host, port, username=username, password=password)
        self.db = self.client['budgetron']
        self.users_collection = self.db['users']
        self.accounts_collection = self.db['accounts']
        self.transactions_collection = self.db['transactions']
    
    def save_account(self, account : Account) -> str:
        """
        Save an account in the database
        
        Parameters:
        ----------
        account: Account
            The account to save
        
        Returns:
        -------
        str
            The id of the saved account
        
        Raises:
        ------
        Exception
            If the account insertion failed
        Exception
            If the account number already exists
        """

        # Remove the id field from the account
        account_dict = account.model_dump()
        del account_dict['id']
        account_dict['transactions'] = [ObjectId(t) for t in account_dict['transactions']]
        # Verify that the account number does not already exist
        account_in_db = self.accounts_collection.find_one({'number': account.number})
        if account_in_db is not None:
            raise Exception("Account number already exists")

        # Handle failed insertion
        saved_account = self.accounts_collection.insert_one(account_dict)
        if saved_account is None:
            raise Exception("Failed to save account")
        return str(saved_account.inserted_id)
    
    def save_transaction(self, transaction : Transaction) -> str:

        """
        Save a transaction in the database
        
        Parameters:
        ----------
        transaction: Transaction
            The transaction to save
        
        Returns:
        -------
        str
            The id of the saved transaction
        
        Raises:
        ------
        Exception
            If the transaction insertion failed
        """

        # Remove the id field from the transaction
        transaction_dict = transaction.model_dump()
        # Remove the id field from the transaction (the id is generated by the database)
        del transaction_dict['id']

        saved_transaction = self.transactions_collection.insert_one(transaction_dict)
        # Handle failed insertion
        if saved_transaction is None:
            raise Exception("Failed to save transaction")
        return str(saved_transaction.inserted_id)

    def get_account(self, account_id : str) -> Account:
        """
        Get an account from the database
        
        Parameters:
        ----------
        account_id: str
            The id of the account to get
        
        Returns:
        -------
        Account
            The account retrieved from the database
        """
        account = self.accounts_collection.find_one({'_id': ObjectId(account_id)})
        
        if account is None:
            return None
        
        # Convert the id from ObjectId to str
        account['_id'] = str(account['_id'])
        account['transactions'] = [str(t) for t in account['transactions']]

        return Account(**account)
    
    def get_account_by_number(self, account_number : str) -> Account:
        """
        Get an account from the database
        
        Parameters:
        ----------
        account_number: str
            The number of the account to get
        
        Returns:
        -------
        Account
            The account retrieved from the database
        """
        account = self.accounts_collection.find_one({'number': account_number})
        account['_id'] = str(account['_id'])
        if account is None:
            return None
        return Account(**account)

    def get_transaction(self, transaction_id : str) -> Transaction:
        """
        Get a transaction from the database
        
        Parameters:
        ----------
        transaction_id: str
            The id of the transaction to get
        
        Returns:
        -------
        Transaction
            The transaction retrieved from the database
        """
        transaction = self.transactions_collection.find_one({'_id': ObjectId(transaction_id)})
        transaction['_id'] = str(transaction['_id'])
        if transaction is None:
            return None
        return Transaction(**transaction)
    
    def get_transactions(self, account_id : str) -> list[Transaction]:
        """
        Get all the transactions from an account
        
        Parameters:
        ----------
        account_id: str
            The id of the account to get the transactions from
        
        Returns:
        -------
        list[Transaction]
            The list of transactions retrieved from the database
        """
        account = self.get_account(account_id)
        if account is None:
            return None
        
        transactions = self.transactions_collection.find({'_id': {'$in': [ObjectId(t) for t in account.transactions]}})
        

        if transactions is None:
            return None
        
        res = []
        for t in transactions:
            t['_id'] = str(t['_id'])
            t['account_id'] = str(t['account_id'])
            res.append(Transaction(**t))
        return res
    
    def verify_user(self, authentication_hash : str) -> User:
        """
        Verify that a user exists in the database
        
        Parameters:
        ----------
        authentication_hash: str
            The authentication hash of the user to verify
        
        Returns:
        -------
        User
            The user retrieved from the database (None if the user does not exist)
        """
        user = self.users_collection.find_one({'authentication_hash': authentication_hash})
        if user is None:
            return None
        # Convert the id from ObjectId to str
        user['_id'] = str(user['_id'])
        # Delete None fields
        user = {k: v for k, v in user.items() if v is not None}
        return User(**user)
    
    def update_user(self, user_id : str, **kwargs) -> None:
        """
        Update a user in the database
        
        Parameters:
        ----------
        user_id: str
            The id of the user to update
        **kwargs
            The fields to update
        """
        self.users_collection.update_one({'_id': ObjectId(user_id)}, {'$set': kwargs})
    
    def unique_email(self, email : str) -> bool:
        """
        Verify that an email is unique in the database
        
        Parameters:
        ----------
        email: str
            The email to verify
        
        Returns:
        -------
        bool
            True if the email is unique, False otherwise
        """
        user = self.users_collection.find_one({'email': email})
        return user is None

    def save_user(self, user : User) -> str:
        """
        Save a user in the database
        
        Parameters:
        ----------
        user: User
            The user to save
        
        Returns:
        -------
        str
            The id of the saved user
        
        Raises:
        ------
        Exception
            If the user insertion failed
        """

        # Remove the id field from the user
        user_dict = user.model_dump()

        # Handle failed insertion
        saved_user = self.users_collection.insert_one(user_dict)
        if saved_user is None:
            raise Exception("Failed to save user")
        return str(saved_user.inserted_id)

    def clear(self):
        """
        Drop the database (for testing purposes)
        """
        self.client.drop_database("budgetron")
    
    def backup(self):
        """
        Backup the database into a json file
        """

        collections = ['accounts', 'transactions']

        for collection_name in collections:

            collection = self.db[collection_name]
            # Query all documents in the collection
            cursor = collection.find()

            # Convert documents to a list
            documents = list(cursor)

            # Convert ObjectId to str
            for document in documents:
                # Convert all fields that are ObjectId to str
                for key in document:
                    if isinstance(document[key], ObjectId):
                        document[key] = str(document[key])

            output_file = "model/db/backup/" + collection_name + ".json"

            # Write documents to a JSON file
            with open(output_file, 'w+') as json_file:
                json.dump(documents, json_file)
    

